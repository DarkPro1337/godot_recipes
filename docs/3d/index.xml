<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>3D on Godot Recipes</title>
    <link>https://kidscancode.org/godot_recipes/3d/</link>
    <description>Recent content in 3D on Godot Recipes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Apr 2019 20:23:50 -0700</lastBuildDate><atom:link href="https://kidscancode.org/godot_recipes/3d/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Camera Gimbal</title>
      <link>https://kidscancode.org/godot_recipes/3d/camera_gimbal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/camera_gimbal/</guid>
      <description>Problem You need a camera controller, using mouse or keyboard, that remains level while rotating and following a target.
Solution Try this: take a Camera node and rotate it a small amount around X (the red ring on the gizmo), then a small amount around Z (the blue ring). Now reverse the X rotation and click the &amp;ldquo;Preview&amp;rdquo; button. Observe how the camera is now tilted.
The solution to this problem is to place the camera on a gimbal - a device designed to keep an object level during movement.</description>
    </item>
    
    <item>
      <title>Interpolated Camera</title>
      <link>https://kidscancode.org/godot_recipes/3d/interpolated_camera/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/interpolated_camera/</guid>
      <description>Problem You need a 3D camera that smoothly follows a target (interpolates).
Solution  div.notices.info p:first-child:after { content: &#39;Info&#39;!important; }  Godot&amp;rsquo;s built-in InterpolatedCamera node is deprecated and will be removed in the release of Godot 4.0.
 Attach the script below to a Camera node in your scene. The three export properties let you choose:
 lerp_speed - the camera&amp;rsquo;s movement speed. Lower values result in a &amp;ldquo;lazier&amp;rdquo; camera. target_path - choose the camera&amp;rsquo;s target node.</description>
    </item>
    
    <item>
      <title>KinematicBody: Movement</title>
      <link>https://kidscancode.org/godot_recipes/3d/kinematic_body/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/kinematic_body/</guid>
      <description>Problem You need a player-controlled 3D kinematic body.
Solution For this recipe, we&amp;rsquo;ll be using this adorable tank model:
You can grab this model on Itch.io: https://gtibo.itch.io/mini-tank or use any other model you&amp;rsquo;d like. We won&amp;rsquo;t be doing anything that&amp;rsquo;s tank-specific here.
We can add the model to the scene, but we&amp;rsquo;ll need a couple of additional nodes:
For the collision shape, we&amp;rsquo;re just going to use a BoxShape aligned and sized with the tank&amp;rsquo;s treads.</description>
    </item>
    
    <item>
      <title>3D Unit Healthbars</title>
      <link>https://kidscancode.org/godot_recipes/3d/healthbars/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/healthbars/</guid>
      <description>Problem You want a floating &amp;ldquo;healthbar&amp;rdquo; for your 3D game objects (mobs, characters, etc.).
Solution For this solution, we&amp;rsquo;re going to re-use a 2D healthbar based on a TextureProgress node. It&amp;rsquo;s already set up with textures and code for updating the value and color. If you already have something similar, feel free to use it here. In the example, we&amp;rsquo;ll name this scene &amp;ldquo;Healthbar2D&amp;rdquo;.
If you need some assets, here are the three images used in the bar:</description>
    </item>
    
    <item>
      <title>Shooting projectiles</title>
      <link>https://kidscancode.org/godot_recipes/3d/3d_shooting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/3d_shooting/</guid>
      <description>Problem You want to shoot projectiles from your player/mob/etc..
Solution For this example, we&amp;rsquo;ll use the &amp;ldquo;Mini Tank&amp;rdquo; that we set up in KinematicBody: Movement.
Setting up the bullet First, we&amp;rsquo;ll set up a &amp;ldquo;bullet&amp;rdquo; object that we can instance. Here are the nodes we&amp;rsquo;ll use:
 Area: Bullet  MeshInstance  CollisionShape For your mesh, you can use one of Godot&amp;rsquo;s built-in primitive shapes, or something like this:
 div.</description>
    </item>
    
    <item>
      <title>Rolling Cube</title>
      <link>https://kidscancode.org/godot_recipes/3d/rolling_cube/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/rolling_cube/</guid>
      <description>Problem You want to make a rolling cube in 3D.

Solution Rolling a cube is trickier than it seems. You can&amp;rsquo;t just rotate the cube around its center:
Instead, the cube needs to be rotated around its bottom edge.
Here&amp;rsquo;s the tricky part: which bottom edge? It depends on which direction the cube is rolling.
In preparing this recipe, I experimented with a few different solutions to this problem:</description>
    </item>
    
    <item>
      <title>Align Movement with Camera</title>
      <link>https://kidscancode.org/godot_recipes/3d/move_with_camera/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/move_with_camera/</guid>
      <description>Problem When moving with WASD-style controls in 3D, it&amp;rsquo;s easy to get disoriented if the camera rotates. Whose forward counts - the player&amp;rsquo;s (ie the camera&amp;rsquo;s) or the object in the game world?
Solution While this situation can apply to many possible scenarios, we&amp;rsquo;ll use the Rolling Cube recipe as our example.
In the script for the cube, we have the following code for movement:
func _physics_process(_delta): var forward = Vector3.</description>
    </item>
    
    <item>
      <title>Simplified Airplane Controller</title>
      <link>https://kidscancode.org/godot_recipes/3d/simple_airplane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/simple_airplane/</guid>
      <description>Problem You want to make an airplane controller in 3D, but don&amp;rsquo;t need a fully accurate flight-simulator.
Solution In this recipe, we&amp;rsquo;re going to make a simplified airplane controller. By &amp;ldquo;simplified&amp;rdquo; we mean stripping things down to the basics. We&amp;rsquo;re looking for the &amp;ldquo;feel&amp;rdquo; of flying a plane - one that you can just jump in and start flying effortlessly, with a minimal control scheme.
 div.notices.note p:first-child:after { content: &#39;Note&#39;!</description>
    </item>
    
    <item>
      <title>Arcade-style Spaceship</title>
      <link>https://kidscancode.org/godot_recipes/3d/spaceship/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/spaceship/</guid>
      <description>Problem You want to make a 3D spaceship that flies in an arcade/cinematic way. You&amp;rsquo;re not looking for realistic physics, but more of a dog-fighting, &amp;ldquo;Star Wars&amp;rdquo;-style of spaceflight.
Solution To accomplish this, we&amp;rsquo;ll use a  KinematicBody for the ship. The three axis inputs (pitch, roll, and yaw) will rotate the body&amp;rsquo;s basis around the corresponding axis. The direction of motion will always point forward.
 div.notices.note p:first-child:after { content: &#39;Note&#39;!</description>
    </item>
    
    <item>
      <title>Drawing Vectors in 3D</title>
      <link>https://kidscancode.org/godot_recipes/3d/debug_overlay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/debug_overlay/</guid>
      <description>Problem You&amp;rsquo;d like visual debug information in your 3D game: a way to see vectors representing velocity, position, etc.
Solution Debug drawing in 2D is quite convenient. CanvasItem provides a range of primitive drawing methods to use in the _draw() callback. In 3D, things are not quite so simple. One solution is to use ImmediateGeometry to manually create meshes, but this is very cumbersome and inconvenient for quick debugging.
A better solution is to stick with the CanvasItem draw methods.</description>
    </item>
    
    <item>
      <title>Click to move</title>
      <link>https://kidscancode.org/godot_recipes/3d/click_to_move/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/click_to_move/</guid>
      <description>Problem You want to move a 3D object to a clicked position.
Solution We&amp;rsquo;ll start with a flat plane for our world. Our actor will move on this plane.
The actor for this demo is a triangular prism mesh:
Here is the code for the movement. If given a target, the object will turn and move toward it.
extends KinematicBody export var speed = 5 export var gravity = -5 var target = null var velocity = Vector3.</description>
    </item>
    
    <item>
      <title>Quick Arcade-style Car</title>
      <link>https://kidscancode.org/godot_recipes/3d/3d_sphere_car/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/3d_sphere_car/</guid>
      <description>Problem You want to make an arcade-style car game, so you&amp;rsquo;re looking for simplicity over realistic physics. In this recipe, you&amp;rsquo;ll learn how to make a fun, driveable car using a rolling sphere.

Solution There are a lot of ways to make a driving game. Different games need different levels of realism. If you&amp;rsquo;re trying to make a light, arcade-style car, you don&amp;rsquo;t need all of the features that Godot&amp;rsquo;s VehicleBody node provides, such as supension, independently modeled wheels, etc.</description>
    </item>
    
    <item>
      <title>Smooth rotation</title>
      <link>https://kidscancode.org/godot_recipes/3d/rotate_interpolate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/rotate_interpolate/</guid>
      <description>Problem You want to smoothly rotate a 3D object to point in a new direction.
Solution When you first encounter this problem, you may find yourself thinking in terms of Euler angles - the three values representing the angles to the x/y/z axes. While Godot will allow you to see the object&amp;rsquo;s Euler angles in the rotation property, it is not recommended to use them to work in 3D. There are a number of reasons why this the case, such as a problem called &amp;ldquo;gimbal lock&amp;rdquo;, where you lose one degree of freedom when one of your rotations reaches 90 degrees.</description>
    </item>
    
    <item>
      <title>KinematicBody: align with surface</title>
      <link>https://kidscancode.org/godot_recipes/3d/3d_align_surface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kidscancode.org/godot_recipes/3d/3d_align_surface/</guid>
      <description>Problem You need your kinematic body to align with the surface or terrain.
Solution This recipe builds on the basic KinematicBody controller described in the KinematicBody: Movement recipe, so read that one first.
First, we&amp;rsquo;ve added some terrain to the scene. You can download the terrain from here: https://fertile-soil-productions.itch.io/modular-terrain-pack. This is low-poly terrain, but you can use or make any terrain you like for this technique.
As you can see, the movement still works with the terrain, but the tank seems to &amp;ldquo;float&amp;rdquo; above the slopes because it doesn&amp;rsquo;t change its orientation.</description>
    </item>
    
  </channel>
</rss>
